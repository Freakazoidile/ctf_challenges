<h2>Goal</h2>

The objective of this task is straight forward, call win() function. But how? Functions are given a address in memory, which is where we will start.

```
objdump -d stack3 | grep win
OUTPUT: 08048424 <win>
```
Using the `objdump` command on the executable, and using `grep` to target the function name the win function is located at `08048424`.  In little endian this is `\x24\x84\x04\x08`. (This value is likely to be different for other people)


Looking at the code `buffer` variable is 64bytes. After the 64bytes is allocated a variable `fp = 0` is declared.  This means we should be able to simply overwrite the `fp` variable like before.  The code tests to determine if `fp` is not set to 0, if it is not it will call the value of it. This is where we want to memory address of the win function to be so it will jump to the win function.

Just like the previous examples time the 65th byte should be what overwrites the next variable, `fp`. I decided to send 70bytes as a test to see if infact `fp` is overwritten.

```
python -c 'print "A"*70' | ./stack3
	seg fault
	calling function pointer, jumping to 0x41414141
```
The presence of the string that is within the `if(fp)` check was printed, with a value of `0x41414141`, or `AAAA`.  

Let's go ahead and send 64bytes of "A" like the previous challenges followed by the little endian address of the win function.

<h2>Solution</h2>

python -c 'print "A"*64+"\x24\x84\x04\x08"' | ./stack3
