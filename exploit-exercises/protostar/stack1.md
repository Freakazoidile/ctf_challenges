<h2>Goal</h2>
Buffer is 64 chars long.  An if statement then checks to see if the overflowed value, byte 65, is `0x61626364`.


Keep in mind it needs to be little endian, so reverse the order to get `"\x64\x63\x62\x61"`

In the code of the target executable the variable called `modified` is declared, followed on the next line by the declaration of the variable `buffer`. Meaning `buffer` is directly on top of `modified` in the stack. Remember that `modified` would be placed in a lower memory address than `buffer`. So by overflowing `buffer` the 65th byte will overwrite the `modified` variable.



<h2>Solution</h2>
This time we provide an argument, instead of sending input to the code.  Hence python is not piped into the executable.
```
./stack1 `python -c 'print "A"*64+"\x64\x63\x62\x61"'`
```
